<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongxinhub.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="c语言的源文件以.c结尾，编译器会以c语言的语法编译.c文件stdio.h是c语言的标准输入输出头文件，比如printf库就包含其中。c语言规定main函数是程序的入口，main函数有且仅有一个">
<meta property="og:type" content="article">
<meta property="og:title" content="c语言笔记">
<meta property="og:url" content="https://kongxinhub.github.io/project/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="孔鑫的个人博客">
<meta property="og:description" content="c语言的源文件以.c结尾，编译器会以c语言的语法编译.c文件stdio.h是c语言的标准输入输出头文件，比如printf库就包含其中。c语言规定main函数是程序的入口，main函数有且仅有一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kongxinhub.github.io/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%841.png">
<meta property="og:image" content="https://kongxinhub.github.io/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%842.png">
<meta property="article:published_time" content="2025-07-13T14:37:24.000Z">
<meta property="article:modified_time" content="2025-11-27T09:30:51.844Z">
<meta property="article:author" content="Kongxin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kongxinhub.github.io/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%841.png">


<link rel="canonical" href="https://kongxinhub.github.io/project/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kongxinhub.github.io/project/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0.html","path":"c语言笔记.html","title":"c语言笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>c语言笔记 | 孔鑫的个人博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">孔鑫的个人博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">2</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">6</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">c语言中的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F"><span class="nav-text">c语言变量常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-text">转义字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">C语言操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">常见关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88"><span class="nav-text">数组&amp;指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-text">字符函数和字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">动态内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84"><span class="nav-text">柔性数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6"><span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="nav-text">文件读写函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-text">文本文件和二进制文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-text">预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7"><span class="nav-text">预定义符号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-text">条件编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="nav-text">文件包含</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kongxin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Kongxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/kongxinhub" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kongxinhub" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongxinhub.github.io/project/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kongxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孔鑫的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="c语言笔记 | 孔鑫的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c语言笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-13 14:37:24" itemprop="dateCreated datePublished" datetime="2025-07-13T14:37:24+00:00">2025-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-27 09:30:51" itemprop="dateModified" datetime="2025-11-27T09:30:51+00:00">2025-11-27</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>c语言的源文件以.c结尾，编译器会以c语言的语法编译.c文件<br>stdio.h是c语言的标准输入输出头文件，比如printf库就包含其中。<br>c语言规定main函数是程序的入口，main函数有且仅有一个</p>
<span id="more"></span>
<h3 id="c语言中的数据类型"><a href="#c语言中的数据类型" class="headerlink" title="c语言中的数据类型"></a>c语言中的数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">char          // 1</span><br><span class="line">short         // 2</span><br><span class="line">int           // 4</span><br><span class="line">long          // 4</span><br><span class="line">long long     // 8</span><br><span class="line">float         // 4</span><br><span class="line">double        // 8</span><br><span class="line"></span><br><span class="line">// 输入输出格式化函数</span><br><span class="line">scanf(&quot;%4d%2d&quot;, &amp;num1, &amp;num2);</span><br><span class="line">printf(&quot;%zu&quot;, sizeof(char)); // %zu表示sizeof返回的无符号整数值  </span><br><span class="line">print(&quot;%.1f&quot;, a); // 打印小数点后一位</span><br><span class="line">printf返回的打印的字符的个数  </span><br><span class="line">%d 打印整型</span><br><span class="line">%u 打印无符号整数 </span><br><span class="line">%c 打印字符</span><br><span class="line">%s 打印字符串</span><br><span class="line">%f 打印float类型的数据</span><br><span class="line">%lf 打印double类型的数据</span><br><span class="line">%zu 打印sizeof的返回值</span><br><span class="line">%2d 两位右对齐</span><br><span class="line">%-2d 两位左对齐</span><br><span class="line"></span><br><span class="line">1byte = 8bit</span><br><span class="line">1 kb = 1024 b 1 mb = 1024 kb gb tb pb</span><br></pre></td></tr></table></figure>
<p>程序everything 查询任意文件地址  </p>
<h3 id="c语言变量常量"><a href="#c语言变量常量" class="headerlink" title="c语言变量常量"></a>c语言变量常量</h3><p>外部符号变量声明方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.c</span><br><span class="line">int a = 10; // 全局变量</span><br><span class="line">b.c</span><br><span class="line">extern int a;</span><br></pre></td></tr></table></figure>
<p>局部变量的声明周期：进入作用域开始，出作用域结束<br>全局变量的生命周期：整个程序的生命周期<br>C语言中的常量种类：</p>
<ul>
<li>字面常量  </li>
<li>const修饰的常变量，本质是变量，但不能修改  </li>
<li>#define定义的标识符常量  </li>
<li>枚举常量</li>
</ul>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table>
<thead>
<tr>
<th align="center">转义字符</th>
<th align="center">释义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\?</td>
<td align="center">在书写连续多个问号时使用，防止被解析成三字母词</td>
</tr>
<tr>
<td align="center">\‘</td>
<td align="center">用于表示字符常量’</td>
</tr>
<tr>
<td align="center">\“</td>
<td align="center">用于表示一个字符串内部的双引号</td>
</tr>
<tr>
<td align="center">\\</td>
<td align="center">用于表示一个反斜杠，防止被解释成转义符</td>
</tr>
<tr>
<td align="center">\a</td>
<td align="center">警告字符，蜂鸣</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">退格符</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">进纸符</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">水平制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">垂直制表符</td>
</tr>
<tr>
<td align="center">\ddd</td>
<td align="center">ddd表示1-3个八进制数字</td>
</tr>
<tr>
<td align="center">\xdd</td>
<td align="center">dd表示2个十六进制数字</td>
</tr>
</tbody></table>
<h3 id="C语言操作符"><a href="#C语言操作符" class="headerlink" title="C语言操作符"></a>C语言操作符</h3><p>算术操作符：+ - * &#x2F; %(取模操作符的两个操作数必须是整数)<br>移位操作符：&lt;&lt; &gt;&gt;<br>位操作符： &amp; ^ |<br>赋值操作符： &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D;<br>单目运算符： ! - + &amp;(取地址) *(解引用) ~(按位取反) – ++ <strong>sizeof</strong>  (类型) (强制类型转换)<br>c语言中，0表示假，非0表示真  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof(x): x在内存中所占字节大小</span><br><span class="line">int arr[10] = &#123;0&#125;;</span><br><span class="line">printf(&quot;%d/n&quot;, sizeof(arr)); //40 计算的是整个数据的大小，单位为字节 </span><br></pre></td></tr></table></figure>
<p>关系操作符：&gt; &gt;&#x3D; &lt; &lt;&#x3D; !&#x3D; &#x3D;&#x3D;<br>逻辑操作符： &amp;&amp; ||<br>条件操作符：exp1 ? exp2 : exp3<br>逗号表达式：逗号隔开的遗传表达式，从左向右依次计算，整个表达式的结果是最后一个表达式的结果<br>下表引用、函数调用和结构成员：[] () . -&gt;  </p>
<h3 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char double float int long short signed unsigned void sizeof </span><br><span class="line">if else goto for do while switch case continue break default return</span><br><span class="line">struct enum extern union typedef const auto static </span><br><span class="line">register volatile</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned int uint_32;</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct Node* next;</span><br><span class="line">&#125;Node;  // struct Node -&gt; Node</span><br></pre></td></tr></table></figure>
<p>变量必须有字母、数字、下划线组成，且不能以数字开头。<br>static 修饰局部变量：局部变量出了作用域不销毁，本质上，static修饰局部变量改变了变量的存储位置(栈区 –&gt; 静态区)，改变了变量的生命周期，和程序的生命周期一样，编译期间已经分配了内存地址；<br>static 修饰全局变量：全局变量是具有外部链接属性的，源文件之间可通过extern使用，但是当static修饰全局变量的时候，全局变量就变成了内部链接属性，只在当前文件中可见，其他源文件就访问不到此全局变量了；<br>static 修饰函数：和全局变量类似，全局函数具有外部链接属性，源文件之间可通过extern使用，但是当static修饰全局函数时，全局函数就变成了内部链接属性，只在当前文件可见。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// a.c</span><br><span class="line">int Add(int x, int y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">// b.c</span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line">extern int Add(int x, int y);</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int z = a + b;</span><br><span class="line">    printf(&quot;%d/n&quot;, z);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    register int num = 3; // 建议3存放到寄存器中</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch必须跟整型表达式，case必须跟整型常量表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ch = getchar();  // getchar返回 的是int类型，如果读取错误返回的是EOF, EOF是定义的宏-1</span><br><span class="line">putchar(ch);</span><br></pre></td></tr></table></figure>
<p>MSDN win32 api查询工具<br>在windows系统中，ctrl+z会被当成EOF<br>gets()可以读包含空格的一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;wimdows.h&gt;</span><br><span class="line">Sleep(1000);</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">system(&quot;cls&quot;); //system是一个库函数，可以执行系统命令</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">srand((unsigned int)time(NULL)); //srand更改随机数种子</span><br><span class="line">rand(); // 根据随机数种子生成随机数</span><br></pre></td></tr></table></figure>
<p>strcmp：比较两个字符串是否相等，返回0表示两个字符串相等<br>strcpy<br>数组传参传的是数组首元素的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">again:</span><br><span class="line">    print(&quot;test&quot;);</span><br><span class="line">    print(&quot;test1&quot;);</span><br><span class="line">    goto again;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goto语句不能跨函数跳转<br>shutdown -s -t 60 倒计时60s关机<br>shutdown -a 取消倒计时关机<br>库函数查询网站：<br><a target="_blank" rel="noopener" href="http://en.cppreference.com/">http://en.cppreference.com</a><br><a target="_blank" rel="noopener" href="http://zn.cppreference.com/">http://zn.cppreference.com</a><br>一个工程里只能有一个main函数<br>数组传参传递的是数组元素的首地址，所以在函数内部不能求形参数组的元素个数<br>bool类型头文件 stdbool.h<br>函数可以嵌套调用，但不能嵌套定义<br>main函数有三个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[], char* envp[])</span><br></pre></td></tr></table></figure>
<p>静态库导入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma comment(lib, &quot;add.lib&quot;)</span><br></pre></td></tr></table></figure>
<p>C99标准之前，数组的大小都是用常量或者常量表达式来指定<br>C99标准之后，支持了变长数组，允许数组的大小是变量，但是这种指定方式的数组是不能初始化的<br>sizeof(数组名)：这里的数组名表示整个数组的大小，计算的是整个数组的大小，单位是字节<br>&amp;数组名：取出的是整个数组的地址<br><img src="/./c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%841.png"><br>二维数组的数组名表示数组第一行的地址<br><img src="/./c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%842.png"></p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>C的整型算术运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前会被转换成普通整型。<strong>整型提升的时候原操作数是无符号数高位直接补0，有符号数高位补充符号位</strong><br>整型提升的意义：表达式的整型运算要在CPU的相应运算器件内执行，CPU内置整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。通用CPU是难以直接实现两个8bit位直接相加运算，所以，表达式中各种长度小于int长度的整型值，都必须先转换为int或unsigned int，然后送入CPU执行计算。<br>指针是最小内存单元的编号，即地址。<br>原码：直接通过正负的形式写出的二进制序列<br>反码：原码符号位不变，其他位按位取反<br>补码：反码+1<br>整型在内存中以补码形式存储，原因在于使用补码可以将符号位和数值域统一处理，同时，加法和减法也可以统一处理。<br>strlen相加减得到的结果是size_t, 即unsigned int类型，因此计算结果为负的时候会得不到预期的结果<br><strong>有符号和无符号计算会转换成无符号计算</strong><br>整型的取值范围定义在limits.h中，浮点型的取值范围等定义在float.h中   </p>
<h3 id="数组-指针"><a href="#数组-指针" class="headerlink" title="数组&amp;指针"></a>数组&amp;指针</h3><p>二维数组传参，函数形参的设计只能省略第一维参数，因为对一个二维数组，可以不知道有多少行，但必须知道有多少列<br>对于函数名来说，&amp;函数名和函数名都是函数的地址。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[] = &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a)); // 16</span><br><span class="line">    // sizeof(数组名)，数组名表示整个数组，计算的是整个数组的大小，单位是字节</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a + 0)); // 4/8</span><br><span class="line">    // a不是单独放在sizeof内部，也没有取地址，所以a就是首元素地址，a+0还是首元素地址</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*a)); // 4</span><br><span class="line">    // *a中的a是数组首元素的地址，*a就是对首元素地址的解引用，找到的就是首元素，首元素的大小为4个字节</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a + 1)); // 4/8</span><br><span class="line">    // 这里的a就是数组首元素的地址，a+1是第二个元素的地址 </span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a[1])); // 4</span><br><span class="line">    // 第二个元素的大小</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;a)); // 4/8、</span><br><span class="line">    // &amp;a取出的是数组的地址</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*&amp;a)); // 16</span><br><span class="line">    // &amp;a --&gt; int(*)[4],数组指针解引用得到的数整个数组a</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;a + 1)); // 4/8</span><br><span class="line">    //  &amp;a --&gt; int(*)[4]，&amp;a + 1指向a的末尾</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;a[0])); // 4/8</span><br><span class="line">    // 第一个元素的地址</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;a[0] + 1)); // 4/8</span><br><span class="line">    // 第二个元素的地址</span><br><span class="line"></span><br><span class="line">    char arr[] = &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(arr)); // 6</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(arr + 0)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*arr)) // 1</span><br><span class="line">    // *arr就是数组的首元素</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(arr[1])); // 1</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;arr)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;arr + 1)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;arr[0] + 1)); // 4/8</span><br><span class="line">    </span><br><span class="line">    # include &lt;string.h&gt;</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(arr)); // 随机值</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(arr + 0)); // 随机值</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(*arr)) // strlen(&#x27;a&#x27;) -&gt; strlen(97) 野指针，错误写法</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(arr[1])); // strlen(&#x27;b&#x27;) -&gt; strlen(97) 野指针，错误写法</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;arr)); // 随机值</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;arr + 1)); // 随机值</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;arr[0] + 1)); // 随机值</span><br><span class="line"></span><br><span class="line">    char arr[] = &quot;abedef&quot;; // a b c d e f \0</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(arr)); // 7</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(arr + 0)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*arr)) // 1</span><br><span class="line">    // *arr就是数组的首元素</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(arr[1])); // 1</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;arr)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;arr + 1)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;arr[0] + 1)); // 4/8</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(arr)); // 6</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(arr + 0)); // 6</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(*arr)) // strlen(&#x27;a&#x27;) -&gt; strlen(97) 野指针，错误写法</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(arr[1])); // strlen(&#x27;b&#x27;) -&gt; strlen(97) 野指针，错误写法</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;arr)); //6</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;arr + 1)); // 随机值</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;arr[0] + 1)); // 5</span><br><span class="line"></span><br><span class="line">    char* p = &quot;abcdef&quot;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(p)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(p + 1)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*p)) // 1?取得是第一个元素？</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(p[0])); // 1</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;p)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;p + 1)); // 4/8</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;p[0] + 1)); // 4/8</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(p)); // 6</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(p + 1)); // 5</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(*p)) // 错误写法</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(p[0])); // 错误写法</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;p)); //随机值</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;p + 1)); // 随机值</span><br><span class="line">    printf(&quot;%d\n&quot;, strlen(&amp;p[0] + 1)); // 5</span><br><span class="line"></span><br><span class="line">    int a[3][4] = &#123;0&#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a)); // 48</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a[0][0])); // 4</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a[0])); // **16, a[0]表示第一行整个一维数组的地址**，单数放在sizeof内部，表示整个一维数组</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a[0] + 1)); // 4/8</span><br><span class="line">    // a[0]没有单独放在sizeof内部，也没取地址，加1后不再代表第一行数组的地址，而是表示a[0]首元素的地址，即a[0][0]的地址-&gt;&amp;a[0][0] + 1</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*(a[0] + 1))); // 4</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a + 1)); // 4/8</span><br><span class="line">    // a没有单独放在sizeof内部，也没取地址，a表示的是首元素的地址，二维数组的首元素是它的第一行，a表示第一行的地址，a+1表示第二行的地址</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*(a + 1))); // 16</span><br><span class="line">    // 对第二行地址解引用</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(&amp;a[0] + 1)); // 4/8</span><br><span class="line">    // &amp;a[0] -&gt; 对第一行的数组名取地址，拿到的是第一行的地址，&amp;a[0]+1得到的就是第二行的地址</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*(&amp;a[0] + 1))); // 16</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(*a)); // 16</span><br><span class="line">    // a表示首元素的地址，即第一行的地址</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(a[3])); // 16</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组名的意义：<br>1、sizeof(数组名),这里的数组名表示整个数组，计算的是整个数组的大小<br>2、&amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址<br>除此之外所有的数组名都表示首元素的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Struct test</span><br><span class="line">&#123;</span><br><span class="line">    int Num;</span><br><span class="line">    char* pcName;</span><br><span class="line">    short sDate;</span><br><span class="line">    char cha[2];</span><br><span class="line">    short sBa[4];</span><br><span class="line">&#125;*p = (struct Test*)0x100000;</span><br><span class="line">// x86环境下，这里结构体大小是20个字节，假设p的值为0x100000</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;%p\n&quot;, p+0x1);</span><br><span class="line">    // p是结构体指针, 0x100000 + 20 --&gt; 0x100014</span><br><span class="line">    printf(&quot;%p\n&quot;, (unsigned long)p+0x1); // 整型+1--&gt; 0x100001</span><br><span class="line">    printf(&quot;%p\n&quot;, (unsigned int*)p+0x1); // p是无符号整型指针，0x100000 + 4 --&gt; 0x100004</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符函数和字符串函数"><a href="#字符函数和字符串函数" class="headerlink" title="字符函数和字符串函数"></a>字符函数和字符串函数</h3><p>字符串的结束标志是’\0’<br>字符串比较：”abc” &#x3D;&#x3D; “acd”：比较的是两个字符串的地址，而不是字符串内容 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">strlen:  求字符串长度，参数指向的字符串必须以&#x27;/0&#x27;结束，注意函数的返回值为size_t</span><br><span class="line">char * strcpy(char * dest, const char* source); // 拷贝至&#x27;/0&#x27;</span><br><span class="line">char * strcat(char * dest, const char* source); // 字符串追加，目标数据、源数据必须包含&#x27;/0&#x27;，源地址和目标地址不能相同</span><br><span class="line">int strcmp(const char * str1, const char * str2); // 字符串比较函数</span><br><span class="line">// 长度受限制的字符串函数</span><br><span class="line">char * strncpy(char* dest, const char* src, size_t num); // 如果源字符串小于num,在目标后面追加0直到num</span><br><span class="line">char * strncat(char* dest, const char* src, size_t num); // 如果源字符串小于num只会追加src内容；追加完会再追加一个&#x27;/0&#x27;</span><br><span class="line">int strncmp(const char* str1, const char* str2, size_t num);</span><br><span class="line"></span><br><span class="line">char* strstr(const char* str1, const char* str2); // 返回查找到的子串的起始地址</span><br><span class="line">char* strtok(char* str, const char* seq);</span><br><span class="line">/**</span><br><span class="line">seq参数是个字符串，定义了用作分隔符的字符集合</span><br><span class="line">第一个参数指定一个字符串，包含0个或者多个由seq字符串中一个或多个分隔符分割的标记</span><br><span class="line">strtok函数找到str中的下一个标记，并将其替换成&#x27;\0&#x27;,返回标记前的字符串的起始地址，strtok函数会改变被操作的字符串，所以使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改</span><br><span class="line">strtok函数第一次传入不为null的字符串，函数将返回切分出来的第一段字符串，并在内部保存后续字符串的起始地址；</span><br><span class="line">接着继续调用strtok,第一个参数传入numm,函数将在继续查找下一个标记并切分；</span><br><span class="line">如果字符串中不存在更多的标记，则返回null指针。</span><br><span class="line">**/</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">char * strerror (int errnum); // 返回错误码所对应的错误信息，C语言的库函数，在执行失败的时候，都会设置错误码</span><br><span class="line">eg.</span><br><span class="line">int main() &#123;</span><br><span class="line">    // errno -&gt; C语言设置的一个全局的错误码存在的变量，只要调用库函数发生错误，就会将错误码存进该变量</span><br><span class="line">    FILE* pf = fopen(&quot;test.txt&quot;, &quot;r&quot;);</span><br><span class="line">    if (pf == NULL) printf(&quot;%s\n&quot;, strerror(errno));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 字符分类函数</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">iscntrl // 任何控制字符</span><br><span class="line">int isspace(int c) // 空白字符：空格‘ ’，换页‘\f’，换行&#x27;\n&#x27;，回车‘\r’，制表符&#x27;\t&#x27;或者垂直制表符&#x27;\v&#x27;</span><br><span class="line">int isdigit(int c) // 十进制数字 0~9</span><br><span class="line">isxdigit // 十六进制数字，包括所有十进制数字，小写字母a~f，大写字母A~F</span><br><span class="line">islower // 小写字母a~z</span><br><span class="line">isupper // 大写字母A~Z</span><br><span class="line">isalpha // 字母a~z或A~Z</span><br><span class="line">isalnum // 字母或者数字，a~z,A~Z,0~9</span><br><span class="line">ispunct // 标点符号，任何不属于数字或者字母的图形字符（可打印）</span><br><span class="line">isgraph // 任何图形字符</span><br><span class="line">isprint // 任何可打印字符，包括图形字符和空白字</span><br><span class="line">// 字符转换函数</span><br><span class="line">int tolower(int c);</span><br><span class="line">int toupper(int c);</span><br><span class="line">// 内存函数</span><br><span class="line">// memcpy 负责两块独立空间的拷贝，重叠内存的拷贝可以使用memmove</span><br><span class="line">void * memcpy(void * dest, const void* src, size_t num); // 函数memcpy从src的位置开始向后复制num个字节的数据到dest的内存位置</span><br><span class="line">void * memmove(void * dest, const void* src, size_t num); // 和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的</span><br><span class="line">int memcmp(const void* str1, const void* str2, size_t num); // 比较从ptr1和ptr2指针开始的num个字节</span><br><span class="line">void* memset(void* ptr, int value, size_t num);</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体内存对齐：<br>第一个成员在结构体变量偏移量为0的地址处；<br>其他成员变量要对齐到对齐数的整数倍的地址处，对齐数&#x3D; 编译器默认的一个对齐数与<strong>该成员自身大小的较小值</strong>，vs中默认的值为8, gcc没有默认对齐数<br><strong>结构体总大小为最大对齐数的整数倍</strong>，每个成员变量都有一个对齐数。<br>如果嵌套了结构体，<strong>嵌套的结构体对齐到自己的最大对齐数的整数倍处</strong>。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 宏macro offsetof (type, member)</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line">#pragma pack(4); // 设置默认对齐数为8</span><br><span class="line">struct S1 &#123;</span><br><span class="line">    char c1;</span><br><span class="line">    int num;</span><br><span class="line">    char c2;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(offsetof(struct S1, c1));</span><br><span class="line">    printf(offsetof(struct S1, c2));</span><br><span class="line">    printf(offsetof(struct S1, num));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#pragma pack(4) // 取消设置的默认对齐数，还原为默认</span><br></pre></td></tr></table></figure>
<p>为什么存在内存对齐：  </p>
<ol>
<li>平台 原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特<br>定类型的数据，否则抛出硬件异常；</li>
<li>性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li>
</ol>
<p>总体来说：结构体的内存对齐是拿空间来换取时间的做法。  </p>
<p>位段的声明和结构体类似，有两个不同：位段的成员必须要整型，位段的成员名后面有一个冒号和一个数字  </p>
<ol>
<li>位段的成员可以是int unsigned int signed int 或者是 char （属于整形家族）类型</li>
<li><strong>位段在空间上是按照以4个字节（int ）或者1个字节（char ）的方式来扩展开辟的</strong>。</li>
<li>位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    int _a:2;  // 表示_a只占2个比特位</span><br><span class="line">    int _b:5;</span><br><span class="line">    int _c:10; </span><br><span class="line">    int _d:30;</span><br><span class="line">&#125;</span><br><span class="line">// 整体大小8个字节</span><br></pre></td></tr></table></figure>
<p>位段不支持跨平台，位段在网络里用的比较多(报头)。<br>联合(union)的大小至少是最大成员的大小。<br>当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。  </p>
<h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 申请一块连续可用的指定字节数的内存，返回指向该空间的指针。如果开辟失败，则返回一个NULL指针</span><br><span class="line">void* malloc (size_t num);</span><br><span class="line">// 动态内存的释放和回收,malloc和free都声明在 stdlib.h 头文件中</span><br><span class="line">void free(void* ptr);</span><br><span class="line">// calloc 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。</span><br><span class="line">// 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。</span><br><span class="line">void* calloc(size_t num, size_t size);</span><br><span class="line"></span><br><span class="line">void* realloc(void* ptr, size_t);</span><br><span class="line">// ptr 是要调整的内存地址, size 调整之后新大小, 返回值为调整之后的内存起始位置</span><br><span class="line">// 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间</span><br><span class="line">// realloc在调整内存空间的是存在两种情况: 原有空间之后有足够大的空间,要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化;</span><br><span class="line">// 原有空间之后没有足够多的空间时，扩展的方法是：在堆空间上另找一个合适大小的连续空间来使用。这样函数返回的是一个新的内存地址</span><br></pre></td></tr></table></figure>
<h3 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h3><p>C99 中，结构中的最后一个元素允许是未知大小的数组，这就叫做『柔性数组』成员。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct st_type</span><br><span class="line"> &#123;</span><br><span class="line"> int i;</span><br><span class="line"> int a[];//柔性数组成员</span><br><span class="line">&#125;type_a;</span><br><span class="line">int i = 0;</span><br><span class="line">type_a *p = (type_a*)malloc(sizeof(type_a)+100*sizeof(int));</span><br><span class="line"> //业务处理</span><br><span class="line">p-&gt;i = 100;</span><br><span class="line"> for(i=0; i&lt;100; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> p-&gt;a[i] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> free(p);</span><br><span class="line"> p = NULL;</span><br></pre></td></tr></table></figure>
<p>结构中的柔性数组成员前面必须至少一个其他成员，一定是最后一个成员；<br>sizeof 返回的这种结构大小不包括柔性数组的内存。<br>包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大<br>小，以适应柔性数组的预期大小。<br>好处：方便内存释放；有利于访问速度。  </p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名<br>字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统<br>声明的，取名FILE.例如，VS2013编译环境提供的 stdio.h 头文件中有以下的文件类型申明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _iobuf &#123;</span><br><span class="line"> char *_ptr;</span><br><span class="line"> int   _cnt;</span><br><span class="line"> char *_base;</span><br><span class="line"> int   _flag;</span><br><span class="line"> int  _file; </span><br><span class="line"> int   _charbuf;</span><br><span class="line"> int   _bufsiz;</span><br><span class="line"> char *_tmpfname;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct _iobuf FILE;</span><br></pre></td></tr></table></figure>
<p>不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异。<br>每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，<br>使用者不必关心细节。一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* fopen(const char* file_name, const char* open_mode);</span><br><span class="line">int fclose(FILE* stream);</span><br></pre></td></tr></table></figure>
<p>打开模式：“r”（只读）、“w”（只写）、“a”（追加）、“rb”（只读，二进制文件）、“wb”（只写）、“ab”（追加）、“r+”（读写）、“w+”（读写）、“a+”（读写）、“rb+”（读写）、“wb+”（读写）、“ab+”（读写）  </p>
<h4 id="文件读写函数"><a href="#文件读写函数" class="headerlink" title="文件读写函数"></a>文件读写函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int fgetc(FILE* stream); // 读取一个字符,读取失败返回EOF  </span><br><span class="line">int fputc(int character, FILE* stream); // 写入一个字符，如果成功返回被写入的字符，如果失败返回EOF</span><br><span class="line">char* fgets(char* str, int num, FILE* stream); // 读取一行数据,复制到str中，最多读num-1个字符，最后还会补一个&#x27;\0&#x27;,如果成功返回str,如果失败返回空指针</span><br><span class="line">int fputs(const char* str, FILE* stream); // 写入一行数据，默认追加会写在同一行，需显式添加&#x27;\n&#x27;,成功返回非负值</span><br><span class="line">int fscanf(FILE* stream, const char* format, ... ); // 读取格式化的数据</span><br><span class="line">int fprintf(FILE* stream, const char* format, ... ); // 写入格式化的数据</span><br><span class="line">size_t fread(void * ptr, size_t size, size_t count, FILE* stream); // 将count个size字节大小的元素读到ptr，返回成功读取到的元素的个数</span><br><span class="line">size_t fwrite(const void* ptr, size_t size, size_t count, FILE* stream); // 将ptr开始的count个size字节大小的元素写入stream，ptr是起始地址</span><br><span class="line">int fseek(FILE* stream, long int offset, int origin); // 根据文件指针的位置和偏移量来设置文件指针位置，origin表示起始位置：SEEK_SET文件开始位置，SEEK_CUR文件指针当前位置，SEEK_END文件结束位置</span><br><span class="line">long int ftell(FILE* stream); // 返回当前文件指针相对于文件起始位置的偏移量</span><br><span class="line">void rewind(FILE* stream); // 让文件指针的位置回到文件的起始位置</span><br></pre></td></tr></table></figure>
<p>任何一个C程序，只要运行起来就会默认打开3个流：<br>FILE* stdin - 标准输入流（键盘）scanf<br>FILE* stdout - 标准输出流（屏幕）printf<br>FILE* stderr - 标准错误流（屏幕）<br>因此，可以利用fprintf将信息打印到屏幕上： fprintf(stdout, “%s, %d, %f\n”, s.arr, s.age, a.score);<br>scanf 是针对标准输入流的格式化输入语句<br>printf 是针对标准输出流的格式化输出语句<br>fscanf 是针对所有输入流的格式化输入语句<br>fprintf 是针对所有输出流的格式化输出语句<br>int sscanf(const char* str, const char* format, … ); &#x2F;&#x2F; 从字符串中读取格式化数据<br>int sprintf(char* str, const char* format, … ); &#x2F;&#x2F; 将一个格式化的数据写到字符串中，本质是把格式化的数据转换成字符串  </p>
<h4 id="文本文件和二进制文件"><a href="#文本文件和二进制文件" class="headerlink" title="文本文件和二进制文件"></a>文本文件和二进制文件</h4><p>数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。<br>如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文<br>本文件。<br>一个数据在内存中是怎么存储的呢？<br>字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。<br>如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符一个字节），而<br>二进制形式输出，则在磁盘上只占4个字节（VS2013测试）。   </p>
<p>在文件读取过程中，不能用feof函数的返回值直接用来判断文件是否读取结束。而是应用于当文件读取结束的时候，判断失败原因是读取失败结束，还是遇到文件尾结束。<br>如何判断文件读取结束：<br>文本文件读取是否结束，判断返回值是否为EOF （fgetc ），或者 NULL （fgets ）<br>二进制文件的读取结束判断，判断返回值是否小于实际要读的个数(fread)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int c; // 注意：int，非char，要求处理EOF</span><br><span class="line">    FILE* fp = fopen(&quot;test.txt&quot;, &quot;r&quot;);</span><br><span class="line">    if(!fp) &#123;</span><br><span class="line">        perror(&quot;File opening failed&quot;);</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    //fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF</span><br><span class="line">    while ((c = fgetc(fp)) != EOF) // 标准C I/O读取文件循环</span><br><span class="line">    &#123; </span><br><span class="line">        putchar(c);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是什么原因结束的</span><br><span class="line">    if (ferror(fp))</span><br><span class="line">        puts(&quot;I/O error when reading&quot;);</span><br><span class="line">    else if (feof(fp))</span><br><span class="line">        puts(&quot;End of file reached successfully&quot;);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件缓冲区: ANSIC 标准采用“缓冲文件系统”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序<br>中每一个正在使用的文件开辟一块“文件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装<br>满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓<br>冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根<br>据C编译系统决定的。<br><strong>因为有缓冲区的存在，C语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文<br>件。如果不做，可能导致读写文件的问题.</strong> fflush刷新缓冲区，fclose在关闭文件的时候，也会刷新缓冲区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">//VS2013 WIN10环境测试</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> FILE*pf = fopen(&quot;test.txt&quot;, &quot;w&quot;);</span><br><span class="line"> fputs(&quot;abcdef&quot;, pf);//先将代码放在输出缓冲区</span><br><span class="line"> printf(&quot;睡眠10秒-已经写数据了，打开test.txt文件，发现文件没有内容\n&quot;);</span><br><span class="line"> Sleep(10000);</span><br><span class="line"> printf(&quot;刷新缓冲区\n&quot;);</span><br><span class="line"> fflush(pf);//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘）</span><br><span class="line"> //注：fflush 在高版本的VS上不能使用了</span><br><span class="line"> printf(&quot;再睡眠10秒-此时，再次打开test.txt文件，文件有内容了\n&quot;);</span><br><span class="line"> Sleep(10000);</span><br><span class="line"> fclose(pf);</span><br><span class="line"> //注：fclose在关闭文件的时候，也会刷新缓冲区</span><br><span class="line"> pf = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><h4 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__FILE__  //进行编译的源文件     </span><br><span class="line">__LINE__  //文件当前的行号  </span><br><span class="line">__DATE__  //文件被编译的日期  </span><br><span class="line">__TIME__  //文件被编译的时间  </span><br><span class="line">__STDC__  //如果编译器遵循ANSI C，其值为1，否则未定义</span><br></pre></td></tr></table></figure>
<p>#define 定义标识符: #define name  stuff<br>#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。<br>#define 定义宏: #define name( parament-list ) stuff<br>参数列表的左括号必须与name紧邻, 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分<br>#define DOUBLE( x)   ( ( x ) + ( x ) ) 用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用<br>续行符\之后不能有其他内容，续行符的本质是转义换行符<br>#define 替换规则：  </p>
<ol>
<li>在调用宏时，首先对<strong>参数</strong>进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。</li>
<li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。</li>
<li>最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程</li>
</ol>
<p>宏<strong>参数和#define 定义</strong>中可以出现其他#define定义的符号。但是对于宏不能出现递归宏<br>当预处理器搜索#define定义的符号的时候，字符串常量(引号中的内容)的内容并不被搜索；  </p>
<p><strong>#可以把一个宏参数变成对应的变量字符串</strong>：#define PRINT(N, FORMAT) printf(“the value of “#N” is “FORMAT”\n”, N) PRINT(a, “%d”)<br><strong>##可以把宏定义中位于它两边的符号合成一个符号</strong>，它允许宏定义从分离的文本片段创建标识符。这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define ADD_TO_SUM(num, value) \</span><br><span class="line"> sum##num += value;</span><br><span class="line">int sum5 = 1;</span><br><span class="line">ADD_TO_SUM(5,10); //作用是：给sum5增加10</span><br></pre></td></tr></table></figure>
<p>当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果.宏比函数在程序的规模和速度方面更胜一筹,宏是不受类型限制的；但宏是没法调试的。<br>#undef NAME 用于移除一个宏定义  </p>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line"> #if 常量表达式 //常量表达式由预处理器求值。</span><br><span class="line">    //...</span><br><span class="line"> #endif</span><br><span class="line">如：</span><br><span class="line">#define __DEBUG__ 1</span><br><span class="line"> #if __DEBUG__</span><br><span class="line">    //..</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> 2.多个分支的条件编译</span><br><span class="line">#if 常量表达式</span><br><span class="line">    //...</span><br><span class="line">#elif  常量表达式</span><br><span class="line">    //...</span><br><span class="line">#else</span><br><span class="line">    //...</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> 3.判断是否被定义</span><br><span class="line">#if defined(symbol)</span><br><span class="line">#ifdef symbol</span><br><span class="line"></span><br><span class="line">#if !defined(symbol)</span><br><span class="line">#ifndef symbol</span><br><span class="line"></span><br><span class="line"> 4.嵌套指令</span><br><span class="line">#if defined(OS_UNIX)</span><br><span class="line">    #ifdef OPTION1</span><br><span class="line">        unix_version_option1();</span><br><span class="line">    #endif</span><br><span class="line">    #ifdef OPTION2</span><br><span class="line">        unix_version_option2();</span><br><span class="line">    #endif</span><br><span class="line">#elif defined(OS_MSDOS)</span><br><span class="line">    #ifdef OPTION2</span><br><span class="line">        msdos_version_option2();</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>本地文件包含： #include “filename.h”, 查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标<br>准位置查找头文件。如果找不到就提示编译错误。<br>库文件包含：#include &lt;filename.h&gt;, 查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。<br>因此，对于库文件，也可以使用””包含，但是这样做查找的效率就低些，也不容易区分是库文件还是本地文件了。<br>offsetof宏实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define OFFSETOF(type, name) (size_t)&amp;(*((type*)0)-&gt;name)</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Kongxin
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://kongxinhub.github.io/project/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0.html" title="c语言笔记">https://kongxinhub.github.io/project/c语言笔记.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/hexo-github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95.html" rel="prev" title="hexo + github 博客搭建记录">
                  <i class="fa fa-angle-left"></i> hexo + github 博客搭建记录
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="next" title="c++学习笔记">
                  c++学习笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Kongxin</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"kongxinhub","repo":"kxtalk","client_id":"Ov23liF92RyBCz8lpgux","client_secret":"f649a253ec9e0b1bfc50c8c205ba6df82b3b2057","admin_user":"kongxinhub","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"38c212dbc33e4e3acabc5414e13d23b0"}</script>
<script src="/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
